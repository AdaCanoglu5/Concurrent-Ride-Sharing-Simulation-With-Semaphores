# Concurrent-Ride-Sharing-Simulation-With-Semaphores
Multi threaded program that simulates a ridesharing problem between threads that is synchronized by the usage of mutexes and semaphores written in C.

Detailed information on the work flow of the program:

In the implementation, first the program takes 2 inputs that are the count of the fans of each team. The program checks if each input is a multiple of 2 and their sum is a multiple of 4, if this is not the case the program terminates before creating any threads. If the inputs are valid the program creates specific amount threads with arguments “A” or “B” according to the inputs. Inside the thread function, the thread first locks, checks if there is a spot finding in progress, that is the cars that were looking for a spot found the spots and now are printing to the terminal. If there is progress going on the thread should block until the progress is over. To manage this, a semaphore is used to keep the threads that want to enter to the critical section in a queue. The thread acquires the mutex then checks if inProgress is true, if it is true releases the mutex and calls sem_wait, when the thread is awakened afterwards it will check If inProgress is still true before entering the critical section. Check is done by a while loop, the thread will keep repeating this process until it can enter the critical section. When the thread enters the critical section, first it will print that it is looking for a car, then if the thread is a fan of “A” team, a global integer that tracks the fan counts of “A” team is incremented, same for the “B” team. The thread then checks if a valid combination of fans is possible, that is if there are 4 threads of the same team or 2 threads of each team, if there is no possible combination, thread releases the mutex and calls the sam_wait for the semaphore that is belonging to its team. There is a semaphore for both “A” and “B” team fan threads. After few more threads go through the same process and the last thread that enters the critical section sees that there is a valid combination, the thread then wakes up the threads from the two semaphores according to the found valid combination. The said thread then becomes the driver sets the inProgress value to true and releases the mutex. The rest of the threads that got awakened then acquire the mutex and print that they have found a spot in a car.  The driver thread after printing that they have found a spot, calls sem_wait and blocks, the driver thread is then awakened when all the other threads print that they a found a spot, this is calculated by an integer that is incremented every time a thread prints that they have found a spot. The driver thread after being awakened, prints that they are the captain and driving the car with the car id. The driver thread then awakes 5 or all the threads in the queue, whichever is lower. At least 5 threads are needed to make a guaranteed valid combination. The driver thread then sets the inProgress to false, releases the mutex and terminates. The rest of the threads that found a spot earlier also terminates after printing that they found a spot. The whole process is repeated until all threads finds their rides. The main thread after all fan threads join, prints that the main is terminating and then terminates.

Asemaphore; this semaphore is used for blocking fan threads of “A” team.
Bsemaphore; this semaphore is used for blocking fan threads of “B” team.
inProgressSem; this semaphore is used for managing the queue for the threads that wants to enter the critical section during a spot finding.
driverSemaphore; this semaphore is used for blocking the driver thread to synchronize the print output of the captain.
Mutex lock; this is a single mutex used for most of the critical sections for threads.
